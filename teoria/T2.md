# Tema 2: Eventos y Asincron√≠a en Node.js

---

## √çndice

1. [Introducci√≥n y Prerrequisitos](#1-introducci√≥n-y-prerrequisitos)
2. [El Event Loop: Arquitectura Moderna](#2-el-event-loop-arquitectura-moderna)
3. [Microtasks vs Macrotasks](#3-microtasks-vs-macrotasks)
4. [EventEmitter Moderno](#4-eventemitter-moderno)
5. [Promesas y async/await](#5-promesas-y-asyncawait)
6. [APIs Nativas de Promesas](#6-apis-nativas-de-promesas)
7. [AbortController y Cancelaci√≥n](#7-abortcontroller-y-cancelaci√≥n)
8. [AsyncLocalStorage: Contexto As√≠ncrono](#8-asynclocalstorage-contexto-as√≠ncrono)
9. [Streams con Async Iterators](#9-streams-con-async-iterators)
10. [Patrones y Anti-patrones](#10-patrones-y-anti-patrones)
11. [Manejo de Errores Moderno](#11-manejo-de-errores-moderno)
12. [Herramientas de Debugging y Performance](#12-herramientas-de-debugging-y-performance)
13. [Ejercicios Pr√°cticos](#13-ejercicios-pr√°cticos)

---

## 1. Introducci√≥n y Prerrequisitos

> üìö **Prerrequisito**: Este tema asume que has completado el **Tema 1 - Fundamentos**, donde se introdujo la arquitectura V8 + Libuv, el concepto b√°sico de s√≠ncrono vs as√≠ncrono, y las APIs de promesas de Node.js.

En este tema profundizaremos en:
- El **Event Loop** y sus 6 fases
- **Microtasks vs Macrotasks** y orden de ejecuci√≥n
- **EventEmitter** moderno con promesas e iteradores
- Patrones avanzados de **concurrencia y cancelaci√≥n**
- **AsyncLocalStorage** para contexto en operaciones as√≠ncronas

---

## 2. El Event Loop: Arquitectura Moderna

El Event Loop es el coraz√≥n de Node.js. Permite realizar operaciones de I/O no bloqueantes delegando trabajo al sistema operativo cuando es posible.

### Las 6 Fases del Event Loop

```
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îå‚îÄ‚ñ∫‚îÇ         timers            ‚îÇ  ‚Üê setTimeout(), setInterval()
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚îÇ     pending callbacks     ‚îÇ  ‚Üê Callbacks de I/O diferidos
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚îÇ       idle, prepare       ‚îÇ  ‚Üê Uso interno de Node.js
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚îÇ           poll            ‚îÇ  ‚Üê I/O: conexiones, datos, fs
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚îÇ           check           ‚îÇ  ‚Üê setImmediate()
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îî‚îÄ‚îÄ‚î§      close callbacks      ‚îÇ  ‚Üê socket.on('close')
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Descripci√≥n de cada fase

| Fase | Ejecuta | Ejemplo |
|------|---------|---------|
| **timers** | Callbacks de `setTimeout()` y `setInterval()` | Timeouts expirados |
| **pending callbacks** | Callbacks de I/O diferidos de la iteraci√≥n anterior | Errores TCP |
| **idle, prepare** | Solo uso interno | - |
| **poll** | Obtiene nuevos eventos de I/O, ejecuta callbacks de I/O | Lectura de archivos, conexiones |
| **check** | Callbacks de `setImmediate()` | Ejecutar despu√©s de poll |
| **close callbacks** | Callbacks de cierre | `socket.on('close')` |

### La fase Poll

Es la fase m√°s importante:
1. Calcula cu√°nto tiempo bloquear esperando I/O
2. Procesa eventos en la cola de poll
3. Si no hay timers programados, espera indefinidamente por I/O
4. Si hay timers, vuelve a la fase timers cuando expiren

---

## 3. Microtasks vs Macrotasks

> üìÇ **C√≥digo de ejemplo**: [`codigo/T2/01-event-loop-orden.js`](../codigo/T2/01-event-loop-orden.js)

### Jerarqu√≠a de prioridad

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1. C√≥digo s√≠ncrono (Call Stack)                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  2. process.nextTick() - M√°xima prioridad as√≠ncrona     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  3. Microtasks: Promise.then(), queueMicrotask()        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  4. Macrotasks: setTimeout, setImmediate, I/O           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Ejemplo de orden de ejecuci√≥n

```javascript
console.log('1. S√≠ncrono');

setTimeout(() => console.log('5. setTimeout'), 0);

setImmediate(() => console.log('6. setImmediate'));

Promise.resolve().then(() => console.log('3. Promise'));

queueMicrotask(() => console.log('4. queueMicrotask'));

process.nextTick(() => console.log('2. nextTick'));

console.log('1b. S√≠ncrono tambi√©n');

/* Salida:
1. S√≠ncrono
1b. S√≠ncrono tambi√©n
2. nextTick          ‚Üê M√°xima prioridad async
3. Promise           ‚Üê Microtask
4. queueMicrotask    ‚Üê Microtask
5. setTimeout        ‚Üê Macrotask (timer)
6. setImmediate      ‚Üê Macrotask (check)
*/
```

### process.nextTick() vs setImmediate()

| Caracter√≠stica | process.nextTick() | setImmediate() |
|----------------|-------------------|----------------|
| Cu√°ndo ejecuta | Antes de cualquier I/O | Despu√©s de I/O (fase check) |
| Prioridad | M√°xima | Normal (macrotask) |
| Riesgo | Puede causar "starvation" | Seguro para recursi√≥n |
| Recomendaci√≥n | Usar con moderaci√≥n | Preferido para c√≥digo recursivo |

```javascript
// ‚ö†Ô∏è Cuidado: nextTick recursivo puede bloquear el Event Loop
function recursiveNextTick() {
  process.nextTick(recursiveNextTick); // ¬°Nunca cede al Event Loop!
}

// ‚úÖ Mejor: setImmediate permite que el Event Loop contin√∫e
function recursiveImmediate() {
  setImmediate(recursiveImmediate); // Cede control entre iteraciones
}
```

### queueMicrotask() - API est√°ndar

```javascript
// queueMicrotask es el est√°ndar web para encolar microtasks
queueMicrotask(() => {
  console.log('Ejecutado como microtask');
});

// Equivalente a Promise.resolve().then(), pero m√°s expl√≠cito
```

---

## 4. EventEmitter Moderno

> üìÇ **C√≥digo de ejemplo**: [`codigo/T2/02-eventos-pedidos.js`](../codigo/T2/02-eventos-pedidos.js) y [`codigo/T2/06-eventos-async-iterator.js`](../codigo/T2/06-eventos-async-iterator.js)

El m√≥dulo `node:events` es fundamental para la arquitectura orientada a eventos de Node.js.

### Uso b√°sico con ESM

```javascript
import { EventEmitter } from 'node:events';

const emisor = new EventEmitter();

// Registrar listener
emisor.on('pedido', (producto, cantidad) => {
  console.log(`Pedido recibido: ${cantidad}x ${producto}`);
});

// Emitir evento
emisor.emit('pedido', 'Laptop', 2);
// Output: Pedido recibido: 2x Laptop
```

### M√©todos principales de EventEmitter

| M√©todo | Descripci√≥n |
|--------|-------------|
| `.on(evento, callback)` | Registra listener (permanente) |
| `.once(evento, callback)` | Listener que se ejecuta solo una vez |
| `.emit(evento, ...args)` | Emite el evento con argumentos |
| `.off(evento, callback)` | Elimina un listener espec√≠fico |
| `.removeAllListeners(evento)` | Elimina todos los listeners |
| `.listenerCount(evento)` | Cuenta listeners registrados |

### events.once() con Promesas (Moderno)

Convierte un evento en una Promise, ideal para `async/await`:

```javascript
import { once, EventEmitter } from 'node:events';

const ee = new EventEmitter();

async function esperarConexion() {
  console.log('Esperando conexi√≥n...');
  
  // Simular conexi√≥n despu√©s de 2 segundos
  setTimeout(() => ee.emit('conectado', { ip: '192.168.1.1' }), 2000);
  
  // Esperar el evento como Promise
  const [datos] = await once(ee, 'conectado');
  console.log('Conectado desde:', datos.ip);
}

esperarConexion();
```

### events.once() con timeout usando AbortSignal

```javascript
import { once, EventEmitter } from 'node:events';

const ee = new EventEmitter();

async function esperarConTimeout() {
  try {
    const [datos] = await once(ee, 'respuesta', {
      signal: AbortSignal.timeout(5000)  // Timeout de 5 segundos
    });
    console.log('Respuesta:', datos);
  } catch (err) {
    if (err.name === 'TimeoutError') {
      console.log('Timeout: no hubo respuesta en 5 segundos');
    }
  }
}
```

### events.on() para Iteradores As√≠ncronos

Convierte eventos en un `AsyncIterable` consumible con `for await...of`:

```javascript
import { on, EventEmitter } from 'node:events';

const ee = new EventEmitter();
const ac = new AbortController();

// Simular emisi√≥n de mensajes
let contador = 0;
const intervalo = setInterval(() => {
  ee.emit('mensaje', `Mensaje ${++contador}`);
  if (contador >= 5) {
    clearInterval(intervalo);
    ac.abort();  // Terminar el iterador
  }
}, 1000);

// Consumir eventos como async iterator
async function procesarMensajes() {
  try {
    for await (const [mensaje] of on(ee, 'mensaje', { signal: ac.signal })) {
      console.log('Recibido:', mensaje);
    }
  } catch (err) {
    if (err.name === 'AbortError') {
      console.log('Iteraci√≥n finalizada');
    }
  }
}

procesarMensajes();
```

### captureRejections para handlers async

Captura autom√°tica de errores en handlers as√≠ncronos:

```javascript
import { EventEmitter } from 'node:events';

const ee = new EventEmitter({ captureRejections: true });

// Handler as√≠ncrono que puede fallar
ee.on('procesar', async (datos) => {
  if (!datos.valido) {
    throw new Error('Datos inv√°lidos');
  }
  // Procesar...
});

// Capturar errores autom√°ticamente
ee.on('error', (err) => {
  console.error('Error capturado:', err.message);
});

ee.emit('procesar', { valido: false });
// Output: Error capturado: Datos inv√°lidos
```

---

## 5. Promesas y async/await

### Evoluci√≥n: Callbacks ‚Üí Promesas ‚Üí async/await

```javascript
// ‚ùå Era de los Callbacks (obsoleto)
fs.readFile('archivo.txt', (err, data) => {
  if (err) return handleError(err);
  fs.writeFile('copia.txt', data, (err) => {
    if (err) return handleError(err);
    console.log('Copiado');
  });
});

// ‚ö†Ô∏è Promesas con .then() (v√°lido pero verboso)
fs.promises.readFile('archivo.txt')
  .then(data => fs.promises.writeFile('copia.txt', data))
  .then(() => console.log('Copiado'))
  .catch(handleError);

// ‚úÖ async/await (moderno y recomendado)
try {
  const data = await fs.promises.readFile('archivo.txt');
  await fs.promises.writeFile('copia.txt', data);
  console.log('Copiado');
} catch (err) {
  handleError(err);
}
```

### Estados de una Promise

```
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ    PENDING      ‚îÇ
              ‚îÇ   (pendiente)   ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ                           ‚îÇ
         ‚ñº                           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FULFILLED     ‚îÇ       ‚îÇ    REJECTED     ‚îÇ
‚îÇ   (cumplida)    ‚îÇ       ‚îÇ   (rechazada)   ‚îÇ
‚îÇ                 ‚îÇ       ‚îÇ                 ‚îÇ
‚îÇ  resolve(valor) ‚îÇ       ‚îÇ  reject(error)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Crear una Promise

```javascript
const miPromesa = new Promise((resolve, reject) => {
  // Simular operaci√≥n as√≠ncrona
  setTimeout(() => {
    const exito = Math.random() > 0.2;  // 80% √©xito
    
    if (exito) {
      resolve({ mensaje: 'Operaci√≥n completada', timestamp: Date.now() });
    } else {
      reject(new Error('La operaci√≥n fall√≥'));
    }
  }, 1000);
});

// Consumir con async/await
try {
  const resultado = await miPromesa;
  console.log(resultado.mensaje);
} catch (error) {
  console.error(error.message);
}
```

### Promise.withResolvers() - ES2024 (Node.js v22+)

Nueva API que simplifica crear Promises con control externo:

```javascript
// Forma tradicional (verbosa)
let resolve, reject;
const promise = new Promise((res, rej) => {
  resolve = res;
  reject = rej;
});

// ‚úÖ ES2024: Promise.withResolvers()
const { promise, resolve, reject } = Promise.withResolvers();

// Caso de uso: agregador de eventos
function crearAgregador(cantidadEsperada) {
  const eventos = [];
  const { promise, resolve } = Promise.withResolvers();
  
  return {
    agregar(evento) {
      eventos.push(evento);
      if (eventos.length === cantidadEsperada) {
        resolve(eventos);
      }
    },
    resultado: promise
  };
}

const agregador = crearAgregador(3);
agregador.agregar('evento1');
agregador.agregar('evento2');
agregador.agregar('evento3');

const todos = await agregador.resultado;
console.log(todos);  // ['evento1', 'evento2', 'evento3']
```

### M√©todos est√°ticos de Promise para concurrencia

| M√©todo | Comportamiento | Resultado |
|--------|---------------|-----------|
| `Promise.all([...])` | Fail-fast: rechaza si cualquiera falla | Array de valores o primer error |
| `Promise.allSettled([...])` | Espera a todas, nunca rechaza | Array de `{status, value/reason}` |
| `Promise.any([...])` | Primera exitosa gana | Valor o `AggregateError` |
| `Promise.race([...])` | Primera que se resuelve o rechaza | Valor o error del primero |

```javascript
// Promise.all - Todas deben tener √©xito
try {
  const [usuarios, productos, config] = await Promise.all([
    fetchUsuarios(),
    fetchProductos(),
    fetchConfig()
  ]);
} catch (error) {
  // Si cualquiera falla, se ejecuta el catch
}

// Promise.allSettled - Manejar fallos parciales
const resultados = await Promise.allSettled([
  fetchUsuarios(),
  fetchProductos(),
  fetchConfig()
]);

const exitosos = resultados
  .filter(r => r.status === 'fulfilled')
  .map(r => r.value);

const fallidos = resultados
  .filter(r => r.status === 'rejected')
  .map(r => r.reason);

// Promise.any - Failover autom√°tico
const datos = await Promise.any([
  fetch('https://api-primaria.com/datos'),
  fetch('https://api-backup.com/datos'),
  fetch('https://api-emergencia.com/datos')
]);
// Retorna el primero que tenga √©xito

// Promise.race - Implementar timeout
const conTimeout = await Promise.race([
  fetchDatos(),
  new Promise((_, reject) => 
    setTimeout(() => reject(new Error('Timeout')), 5000)
  )
]);
```

---

## 6. APIs Nativas de Promesas

> üìÇ **C√≥digo de ejemplo**: [`codigo/T2/03-promise-allsettled.js`](../codigo/T2/03-promise-allsettled.js)

Node.js moderno proporciona versiones de sus APIs core basadas en Promesas.

### node:fs/promises

```javascript
import fs from 'node:fs/promises';

// Leer archivo
const contenido = await fs.readFile('datos.json', 'utf-8');
const datos = JSON.parse(contenido);

// Escribir archivo
await fs.writeFile('salida.json', JSON.stringify(datos, null, 2));

// Operaciones de directorio
await fs.mkdir('nuevo-directorio', { recursive: true });
const archivos = await fs.readdir('./src');

// Obtener informaci√≥n del archivo
const stats = await fs.stat('archivo.txt');
console.log('Tama√±o:', stats.size, 'bytes');
console.log('Es directorio:', stats.isDirectory());

// Copiar archivo
await fs.copyFile('origen.txt', 'destino.txt');

// Eliminar archivo
await fs.unlink('temporal.txt');

// Renombrar
await fs.rename('viejo.txt', 'nuevo.txt');
```

### node:timers/promises

```javascript
import { setTimeout, setInterval } from 'node:timers/promises';

// setTimeout como Promise
console.log('Inicio');
const resultado = await setTimeout(2000, 'valor retornado');
console.log(resultado);  // 'valor retornado' (despu√©s de 2s)

// setTimeout con AbortController
const controller = new AbortController();

setTimeout(() => controller.abort(), 1000);  // Cancelar en 1s

try {
  await setTimeout(5000, 'no llegar√°', { signal: controller.signal });
} catch (err) {
  console.log('Timer cancelado');  // Se ejecuta
}

// setInterval como async iterator
let contador = 0;
for await (const timestamp of setInterval(500)) {
  console.log('Tick:', timestamp);
  if (++contador >= 5) break;  // 5 iteraciones
}
```

### node:stream/promises

```javascript
import { pipeline } from 'node:stream/promises';
import fs from 'node:fs';
import zlib from 'node:zlib';

// Pipeline para transformar streams
await pipeline(
  fs.createReadStream('archivo.txt'),
  zlib.createGzip(),
  fs.createWriteStream('archivo.txt.gz')
);
console.log('Archivo comprimido');

// Pipeline con m√∫ltiples transformaciones
import { Transform } from 'node:stream';

const mayusculas = new Transform({
  transform(chunk, encoding, callback) {
    callback(null, chunk.toString().toUpperCase());
  }
});

await pipeline(
  fs.createReadStream('entrada.txt'),
  mayusculas,
  fs.createWriteStream('salida.txt')
);
```

### fetch() nativo (Node.js 18+)

```javascript
// GET request
const response = await fetch('https://api.ejemplo.com/usuarios');
const usuarios = await response.json();

// POST request
const nuevoUsuario = await fetch('https://api.ejemplo.com/usuarios', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({ nombre: 'Ana', email: 'ana@ejemplo.com' })
});

// Con timeout usando AbortSignal
const datos = await fetch('https://api.ejemplo.com/datos', {
  signal: AbortSignal.timeout(5000)  // 5 segundos timeout
});
```

---

## 7. AbortController y Cancelaci√≥n

> üìÇ **C√≥digo de ejemplo**: [`codigo/T2/04-abort-controller.js`](../codigo/T2/04-abort-controller.js)

`AbortController` y `AbortSignal` son el patr√≥n est√°ndar para cancelar operaciones as√≠ncronas.

### Uso b√°sico

```javascript
const controller = new AbortController();
const { signal } = controller;

// Pasar signal a operaci√≥n cancelable
fetch('/api/datos', { signal })
  .then(res => res.json())
  .then(datos => console.log(datos))
  .catch(err => {
    if (err.name === 'AbortError') {
      console.log('Petici√≥n cancelada');
    }
  });

// Cancelar la operaci√≥n
controller.abort();
```

### AbortSignal.timeout() - Timeout autom√°tico

```javascript
// Forma simple de a√±adir timeout
const response = await fetch('/api/datos', {
  signal: AbortSignal.timeout(5000)  // Cancela despu√©s de 5s
});
```

### AbortSignal.any() - Combinar se√±ales (Node.js v20+)

```javascript
const userController = new AbortController();

// Cancelar si: el usuario lo pide O pasan 30 segundos
const combinedSignal = AbortSignal.any([
  userController.signal,
  AbortSignal.timeout(30000)
]);

try {
  const response = await fetch('/api/proceso-largo', { 
    signal: combinedSignal 
  });
} catch (err) {
  if (err.name === 'AbortError') {
    console.log('Cancelado por usuario o timeout');
  }
}

// Bot√≥n de cancelar en la UI
botonCancelar.onclick = () => userController.abort();
```

### Integraci√≥n con APIs de Node.js

```javascript
import { once, on } from 'node:events';
import { setTimeout } from 'node:timers/promises';
import fs from 'node:fs';

// Con events.once()
const [data] = await once(emitter, 'datos', { 
  signal: AbortSignal.timeout(5000) 
});

// Con events.on() (async iterator)
for await (const event of on(emitter, 'mensaje', { signal })) {
  // Procesar eventos hasta abort
}

// Con timers/promises
await setTimeout(1000, 'valor', { signal: controller.signal });

// Con streams
const stream = fs.createWriteStream('archivo.txt', {
  signal: AbortSignal.timeout(10000)
});
```

### Detectar raz√≥n de cancelaci√≥n

```javascript
const controller = new AbortController();

// Abortar con raz√≥n espec√≠fica
controller.abort(new Error('Usuario cancel√≥ la operaci√≥n'));

// Verificar raz√≥n
controller.signal.addEventListener('abort', () => {
  console.log('Raz√≥n:', controller.signal.reason);
});
```

---

## 8. AsyncLocalStorage: Contexto As√≠ncrono

> üìÇ **C√≥digo de ejemplo**: [`codigo/T2/05-async-local-storage.js`](../codigo/T2/05-async-local-storage.js)

`AsyncLocalStorage` permite mantener contexto a trav√©s de toda la cadena de llamadas as√≠ncronas, similar a Thread-Local Storage en otros lenguajes.

### Caso de uso: Request ID para logging

```javascript
import { AsyncLocalStorage } from 'node:async_hooks';
import { randomUUID } from 'node:crypto';
import http from 'node:http';

const asyncLocalStorage = new AsyncLocalStorage();

// Logger contextual
function log(nivel, mensaje) {
  const store = asyncLocalStorage.getStore();
  const requestId = store?.requestId ?? 'sin-contexto';
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] [${requestId}] [${nivel}] ${mensaje}`);
}

// Simulaci√≥n de acceso a base de datos
async function getUserFromDB(id) {
  log('DEBUG', `Buscando usuario ${id} en BD`);
  await new Promise(r => setTimeout(r, 100));  // Simular latencia
  log('DEBUG', `Usuario ${id} encontrado`);
  return { id, nombre: 'Usuario ' + id };
}

// Servidor HTTP
const server = http.createServer((req, res) => {
  // Crear contexto para esta request
  asyncLocalStorage.run({ requestId: randomUUID(), startTime: Date.now() }, async () => {
    log('INFO', `${req.method} ${req.url}`);
    
    try {
      const usuario = await getUserFromDB(1);
      
      const store = asyncLocalStorage.getStore();
      const duracion = Date.now() - store.startTime;
      log('INFO', `Respuesta enviada en ${duracion}ms`);
      
      res.end(JSON.stringify(usuario));
    } catch (err) {
      log('ERROR', err.message);
      res.statusCode = 500;
      res.end('Error interno');
    }
  });
});

server.listen(3000);
```

### M√©todos de AsyncLocalStorage

| M√©todo | Descripci√≥n |
|--------|-------------|
| `.run(store, callback)` | Ejecuta callback con el store dado |
| `.getStore()` | Obtiene el store actual (o undefined) |
| `.enterWith(store)` | Establece store sin callback (usar con cuidado) |
| `.exit(callback)` | Ejecuta callback sin contexto |
| `.disable()` | Deshabilita la instancia |

### Ejemplo: Transacciones de base de datos

```javascript
import { AsyncLocalStorage } from 'node:async_hooks';

const transactionStorage = new AsyncLocalStorage();

async function withTransaction(callback) {
  const connection = await pool.getConnection();
  await connection.beginTransaction();
  
  try {
    const result = await transactionStorage.run({ connection }, callback);
    await connection.commit();
    return result;
  } catch (error) {
    await connection.rollback();
    throw error;
  } finally {
    connection.release();
  }
}

// Usar la conexi√≥n de la transacci√≥n actual
async function query(sql, params) {
  const store = transactionStorage.getStore();
  const conn = store?.connection ?? pool;  // Usar pool si no hay transacci√≥n
  return conn.query(sql, params);
}

// Uso
await withTransaction(async () => {
  await query('INSERT INTO usuarios (nombre) VALUES (?)', ['Ana']);
  await query('INSERT INTO perfiles (usuario_id) VALUES (LAST_INSERT_ID())');
  // Si algo falla, todo se revierte autom√°ticamente
});
```

---

## 9. Streams con Async Iterators

Los Readable streams implementan `Symbol.asyncIterator`, permitiendo consumirlos con `for await...of`.

### Leer archivo por chunks

```javascript
import fs from 'node:fs';

const stream = fs.createReadStream('archivo-grande.txt', { 
  encoding: 'utf8',
  highWaterMark: 1024  // 1KB por chunk
});

for await (const chunk of stream) {
  console.log(`Chunk recibido: ${chunk.length} caracteres`);
  // Procesar chunk...
}
```

### Procesar l√≠neas de un archivo

```javascript
import fs from 'node:fs';
import readline from 'node:readline';

const rl = readline.createInterface({
  input: fs.createReadStream('datos.csv'),
  crlfDelay: Infinity
});

let lineNumber = 0;
for await (const line of rl) {
  lineNumber++;
  if (lineNumber === 1) continue;  // Saltar header
  
  const [nombre, email, edad] = line.split(',');
  console.log({ nombre, email, edad: parseInt(edad) });
}
```

### M√©todos funcionales en Streams (Node.js moderno)

```javascript
import { Readable } from 'node:stream';

const numeros = Readable.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

const resultado = await numeros
  .filter(n => n % 2 === 0)           // Solo pares
  .map(n => n * 10)                   // Multiplicar por 10
  .take(3)                            // Solo primeros 3
  .toArray();                         // Convertir a array

console.log(resultado);  // [20, 40, 60]
```

### Transformar streams con async/await

```javascript
import { Transform } from 'node:stream';
import { pipeline } from 'node:stream/promises';

// Transform stream con async
const procesador = new Transform({
  objectMode: true,
  async transform(chunk, encoding, callback) {
    try {
      // Operaci√≥n as√≠ncrona por chunk
      const resultado = await procesarAsync(chunk);
      callback(null, resultado);
    } catch (error) {
      callback(error);
    }
  }
});
```

---

## 10. Patrones y Anti-patrones

### ‚úÖ Patrones Recomendados

#### Concurrencia controlada

```javascript
// Procesar en paralelo con l√≠mite de concurrencia
async function procesarConLimite(items, limite, procesador) {
  const resultados = [];
  const ejecutando = new Set();
  
  for (const item of items) {
    const promesa = procesador(item).then(r => {
      ejecutando.delete(promesa);
      return r;
    });
    
    ejecutando.add(promesa);
    resultados.push(promesa);
    
    if (ejecutando.size >= limite) {
      await Promise.race(ejecutando);
    }
  }
  
  return Promise.all(resultados);
}

// Uso: procesar 100 items, m√°ximo 5 en paralelo
const resultados = await procesarConLimite(urls, 5, fetchUrl);
```

#### Error handling centralizado

```javascript
async function fetchUserProfile(userId) {
  try {
    const user = await getUser(userId);
    const posts = await getPosts(user.id);
    const comments = await getComments(user.id);
    return { user, posts, comments };
  } catch (error) {
    // Un solo catch para todo el flujo
    throw new AppError('PROFILE_LOAD_FAILED', { cause: error, userId });
  }
}
```

#### Fallback con .catch()

```javascript
// Intentar primario, caer a backup si falla
const datos = await fetchPrimario()
  .catch(() => fetchBackup())
  .catch(() => ({ default: true }));  // Valor por defecto
```

### ‚ùå Anti-patrones a Evitar

#### forEach con async (NO espera)

```javascript
// ‚ùå MAL: forEach no espera las promises
urls.forEach(async (url) => {
  await fetch(url);  // ¬°Estas promesas flotan sin esperar!
});
console.log('Done');  // Se ejecuta ANTES de que terminen los fetches

// ‚úÖ BIEN: for...of para secuencial
for (const url of urls) {
  await fetch(url);
}

// ‚úÖ BIEN: Promise.all para paralelo
await Promise.all(urls.map(url => fetch(url)));
```

#### await en loop cuando se puede paralelizar

```javascript
// ‚ùå LENTO: Secuencial innecesario
const usuarios = [];
for (const id of ids) {
  const usuario = await fetchUsuario(id);  // Uno por uno
  usuarios.push(usuario);
}

// ‚úÖ R√ÅPIDO: Paralelo
const usuarios = await Promise.all(ids.map(id => fetchUsuario(id)));
```

#### Mezclar callbacks y promesas

```javascript
// ‚ùå Confuso y propenso a errores
function getData(callback) {
  fetchAsync()
    .then(data => callback(null, data))
    .catch(err => callback(err));
}

// ‚úÖ Solo promesas
async function getData() {
  return fetchAsync();
}
```

#### Ignorar promesas (fire and forget sin manejo)

```javascript
// ‚ùå Promesa no manejada puede crashear
saveToDatabase(datos);  // ¬øY si falla?

// ‚úÖ Siempre manejar o usar void expl√≠cito
await saveToDatabase(datos);

// O si realmente es fire-and-forget:
saveToDatabase(datos).catch(err => logger.error(err));
```

---

## 11. Manejo de Errores Moderno

### Error.cause (ES2022) - Encadenar errores

```javascript
async function fetchUsuario(id) {
  try {
    const response = await fetch(`/api/usuarios/${id}`);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return response.json();
  } catch (error) {
    // Encadenar error original como "cause"
    throw new Error(`No se pudo cargar usuario ${id}`, { cause: error });
  }
}

// Acceder a la cadena de errores
try {
  await fetchUsuario(123);
} catch (error) {
  console.log(error.message);        // "No se pudo cargar usuario 123"
  console.log(error.cause?.message); // "HTTP 404"
}
```

### AggregateError - M√∫ltiples errores

```javascript
// Promise.any lanza AggregateError si todas fallan
try {
  await Promise.any([
    fetch('https://api1.com/datos'),
    fetch('https://api2.com/datos'),
    fetch('https://api3.com/datos')
  ]);
} catch (error) {
  if (error instanceof AggregateError) {
    console.log('Todas las APIs fallaron:');
    error.errors.forEach((e, i) => {
      console.log(`  API ${i + 1}: ${e.message}`);
    });
  }
}
```

### Clases de error personalizadas

```javascript
class AppError extends Error {
  constructor(code, options = {}) {
    super(AppError.messages[code] ?? code, options);
    this.code = code;
    this.name = 'AppError';
    this.timestamp = new Date().toISOString();
  }
  
  static messages = {
    USER_NOT_FOUND: 'Usuario no encontrado',
    INVALID_INPUT: 'Datos de entrada inv√°lidos',
    DB_CONNECTION_FAILED: 'Error de conexi√≥n a base de datos'
  };
}

// Uso
throw new AppError('USER_NOT_FOUND', { cause: originalError });
```

### Unhandled Promise Rejections (crashean desde Node v15)

```javascript
// ‚ö†Ô∏è Desde Node.js v15, las promesas no manejadas crashean el proceso
Promise.reject(new Error('oops'));  // Crash!

// Manejador global como safety net (no reemplaza try/catch apropiado)
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection:', reason);
  // En producci√≥n: loggear y crashear para reinicio limpio
  process.exit(1);
});
```

---

## 12. Herramientas de Debugging y Performance

### Debugging con Node.js Inspector

Node.js incluye un debugger integrado compatible con Chrome DevTools:

```bash
# Iniciar con inspector
node --inspect src/index.js

# Pausar en la primera l√≠nea
node --inspect-brk src/index.js
```

Luego abre `chrome://inspect` en Chrome y conecta al proceso Node.js.

**Debugging en VS Code:**
1. Crea `.vscode/launch.json`:
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug",
      "program": "${workspaceFolder}/src/index.js",
      "console": "integratedTerminal"
    }
  ]
}
```
2. Pon breakpoints y presiona F5

### Medir tiempos con console.time

La forma m√°s simple de medir duraci√≥n de operaciones:

```javascript
console.time('fetch-usuarios');
const usuarios = await fetchUsuarios();
console.timeEnd('fetch-usuarios');
// Output: fetch-usuarios: 234.567ms

// M√∫ltiples mediciones simult√°neas
console.time('total');
console.time('paso-1');
await paso1();
console.timeEnd('paso-1');  // paso-1: 100.123ms

console.time('paso-2');
await paso2();
console.timeEnd('paso-2');  // paso-2: 150.456ms

console.timeEnd('total');   // total: 250.789ms
```

### Performance hooks nativos

```javascript
import { performance, PerformanceObserver } from 'node:perf_hooks';

// Observador de m√©tricas
const obs = new PerformanceObserver((items) => {
  items.getEntries().forEach(entry => {
    console.log(`${entry.name}: ${entry.duration.toFixed(2)}ms`);
  });
});
obs.observe({ entryTypes: ['measure'] });

// Medir operaci√≥n
performance.mark('inicio-operacion');

await operacionCostosa();

performance.mark('fin-operacion');
performance.measure('Mi Operaci√≥n', 'inicio-operacion', 'fin-operacion');
```

### Monitorear Event Loop

```javascript
import { monitorEventLoopDelay } from 'node:perf_hooks';

const histogram = monitorEventLoopDelay({ resolution: 20 });
histogram.enable();

// Despu√©s de un tiempo
setInterval(() => {
  console.log({
    min: histogram.min / 1e6,       // Convertir a ms
    max: histogram.max / 1e6,
    mean: histogram.mean / 1e6,
    p99: histogram.percentile(99) / 1e6
  });
  histogram.reset();
}, 5000);
```

### Diagnostics Channel

API moderna de bajo overhead para diagn√≥sticos:

```javascript
import diagnostics_channel from 'node:diagnostics_channel';

// Crear canal
const dbChannel = diagnostics_channel.channel('app:database');

// Suscribirse (en m√≥dulo de observabilidad)
dbChannel.subscribe((message) => {
  console.log(`Query: ${message.sql} - ${message.duration}ms`);
});

// Publicar (en m√≥dulo de base de datos)
async function query(sql) {
  const start = performance.now();
  const result = await db.execute(sql);
  
  if (dbChannel.hasSubscribers) {
    dbChannel.publish({ sql, duration: performance.now() - start });
  }
  
  return result;
}
```

---

## 13. Ejercicios Pr√°cticos

### Ejercicio 1: Orden de ejecuci√≥n del Event Loop

Predice el orden de salida antes de ejecutar:

```javascript
console.log('A');

setTimeout(() => console.log('B'), 0);

Promise.resolve().then(() => console.log('C'));

process.nextTick(() => console.log('D'));

setImmediate(() => console.log('E'));

queueMicrotask(() => console.log('F'));

console.log('G');
```

### Ejercicio 2: Sistema de pedidos con eventos

Implementa un sistema de pedidos usando `EventEmitter` con:
- Evento `'pedido-recibido'` que recibe `{ id, producto, cantidad }`
- Evento `'pedido-procesado'` cuando se completa
- Usa `events.once()` para esperar confirmaci√≥n con timeout de 5 segundos

```javascript
import { EventEmitter, once } from 'node:events';

// Tu c√≥digo aqu√≠...
```

### Ejercicio 3: Lectura de archivos con Promise.allSettled

Lee m√∫ltiples archivos en paralelo y reporta cu√°les exist√≠an y cu√°les no:

```javascript
import fs from 'node:fs/promises';

const archivos = ['config.json', 'datos.txt', 'noexiste.log', 'readme.md'];

// Tu c√≥digo aqu√≠: usar Promise.allSettled para manejar fallos
```

### Ejercicio 4: Timeout con AbortController

Implementa una funci√≥n `fetchConTimeout(url, ms)` que cancele la petici√≥n si excede el tiempo:

```javascript
async function fetchConTimeout(url, ms) {
  // Tu c√≥digo aqu√≠...
}

// Prueba
try {
  const data = await fetchConTimeout('https://api.ejemplo.com/lento', 3000);
} catch (err) {
  console.log('Timeout o error');
}
```

### Ejercicio 5: Logger con AsyncLocalStorage

Implementa un sistema de logging que incluya autom√°ticamente el `requestId` en todos los logs:

```javascript
import { AsyncLocalStorage } from 'node:async_hooks';

const storage = new AsyncLocalStorage();

function log(mensaje) {
  // Tu c√≥digo: obtener requestId del storage
}

async function procesarPeticion(requestId) {
  // Tu c√≥digo: usar storage.run() para establecer contexto
}
```

### Ejercicio 6: Iterador as√≠ncrono de eventos

Crea un sistema que emita n√∫meros cada 500ms y use `events.on()` para procesarlos como async iterator, deteni√©ndose despu√©s de 10 n√∫meros:

```javascript
import { EventEmitter, on } from 'node:events';

// Tu c√≥digo aqu√≠...
```

---

## Resumen

| Concepto | API Moderna | Evitar |
|----------|-------------|--------|
| M√≥dulos | `import from 'node:events'` | `require()` |
| Filesystem | `fs.promises` / `import fs from 'node:fs/promises'` | callbacks de fs |
| Timers | `import { setTimeout } from 'node:timers/promises'` | callbacks |
| Eventos a Promise | `events.once()`, `events.on()` | callback hell |
| Cancelaci√≥n | `AbortController`, `AbortSignal.timeout()` | - |
| Contexto async | `AsyncLocalStorage` | globals, pasar contexto manualmente |
| Streams | `for await...of`, `pipeline()` | eventos `.on('data')` |
| Concurrencia | `Promise.all`, `Promise.allSettled`, `Promise.any` | loops await secuenciales |
| Errores | `Error.cause`, `AggregateError` | ignorar rechazos |

---

## Ejercicio del Curso

Para poner en pr√°ctica los conceptos de este tema, realiza el siguiente ejercicio:

### üçï Pizza Express - Sistema de Pedidos

Simula el sistema de gesti√≥n de pedidos de una pizzer√≠a usando EventEmitter, Promises y async/await.

**Ubicaci√≥n:** `ejercicios/T2/`

**Requisitos:**
1. Clase `PizzaShop` que extienda EventEmitter
2. Eventos: `order:received`, `order:preparing`, `order:baking`, `order:ready`, `order:failed`
3. Simular tiempos aleatorios y posibilidad de fallo
4. Procesar m√∫ltiples pedidos en paralelo con `Promise.allSettled()`

**Conceptos a aplicar:**
- EventEmitter y herencia de clases
- Eventos personalizados
- Promesas y async/await
- Manejo de errores asincr√≥nicos

```bash
cd ejercicios/T2
node src/pizza-shop.js
```

Consulta el README del ejercicio para m√°s detalles.

---

## Referencias

- [Node.js Documentation - Events](https://nodejs.org/api/events.html)
- [Node.js Documentation - Async Hooks](https://nodejs.org/api/async_hooks.html)
- [Node.js Documentation - Timers/Promises](https://nodejs.org/api/timers.html#timers-promises-api)
- [MDN - AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)
- [Node.js Event Loop Explained](https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick)
